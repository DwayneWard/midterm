# Теоретическая часть контрольной работы. Вариант 1
## Разработка на Python. Профессиональный

### Вопрос 1
На продакшн-сервисе ты добавляешь middleware, которое создаёт `request_id` через `uuid4` и пишет его в `request.state`. Что нужно вернуть из middleware, чтобы цепочка обработчиков продолжилась?

А) Результат вызова `await call_next(request)`  
Б) Всегда `JSONResponse`  
В) Только заголовки  
Г) Ничего, middleware завершает обработку

**Правильный ответ:** А

**Проверяемый ОР:** Знает. - Что такое middleware и его роль в обработке запросов и ответов.

### Вопрос 2
Ты реализуешь трассировку: middleware должен добавлять `X-Request-ID` в ответ. Где это сделать?

А) После получения `response = await call_next(request)` добавить заголовок и вернуть  
B) До вызова `call_next` выставить заголовок в `request.headers`  
В) Создать новый `Response` и не вызывать `call_next`  
Г) Передать ID через глобальную переменную

**Правильный ответ:** А

**Проверяемый ОР:** Понимает. - Как middleware интегрируется в жизненный цикл запроса в FastAPI.

### Вопрос 3
Middleware проверяет заголовок `Authorization`. Какие шаги нужны, чтобы вернуть 401 при отсутствии токена? Отметь все подходящие варианты.

А) Считать заголовок из `request.headers`  
Б) При отсутствии токена вернуть `JSONResponse(status_code=401, content=...)` без вызова `call_next`  
В) Пробрасывать запрос дальше без изменений  
Г) При отсутствии токена вернуть `JSONResponse(status_code=401, content=...)` и вызвать `call_next`

**Правильные ответы:** А, Б

**Проверяемый ОР:** Понимает. - Как middleware может улучшить безопасность приложения.

### Вопрос 4
У тебя есть middleware логирования, и оно пишет тело ответа. Почему стоит осторожно читать `response.body_iterator`? Отметь все подходящие причины.

А) Повторное чтение может опустошить поток  
Б) Логирование больших тел увеличивает задержки  
В) Нужно заново создавать `Response`  
Г) FastAPI автоматически клонирует тело

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Понимает. - Как middleware влияет на производительность приложения.

### Вопрос 5
Ты хочешь логировать время обработки запроса. Какие данные стоит сохранить в контексте? Отметь все подходящие варианты.

А) Время начала (timestamp)  
Б) `request.url.path`  
В) `request.method`  
Г) `request.state.user`

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Понимает. - Как трассировка запросов помогает в отладке и мониторинге приложения.

### Вопрос 6
Middleware авторизации кладёт `user_id` в `request.state.user_id`. Ты обрабатываешь запрос внутри `@app.get("/profile")`. Как правильно получить значение `user_id`, чтобы продолжить обработку?

А) `request.state.user_id`  
Б) `request.headers["user_id"]`  
В) `request.app.state.user_id`  
Г) `request.session["user_id"]`

**Правильный ответ:** А

**Проверяемый ОР:** Знает. - Как middleware интегрируется в жизненный цикл запроса в FastAPI.

### Вопрос 7
Redis используется как кеш для списка популярных товаров. Какие ключевые параметры подключения важно определить? Отметь все подходящие варианты.

А) Хост и порт Redis  
Б) Номер базы 
В) Таймаут соединения  
Г) Заголовки запросов 

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Знает. - Основы работы с Redis: установка, настройка, базовые команды (SET, GET, DEL).

### Вопрос 8
Тебе нужно кешировать ответ `GET /products`. Какую TTL выберешь для данных, обновляющихся каждые 10 минут?

А) 600 секунд  
Б) 300 секунд  
В) 1 час  
Г) 10 секунд 

**Правильный ответ:** А

**Проверяемый ОР:** Понимает. - Как кеширование помогает снизить нагрузку на базу данных.

### Вопрос 9
На ревью производительности обсуждают функцию `get_or_set_cache`, которая должна работать с Redis. Какие шаги обязательны? Отметь все подходящие варианты.

А) Попробовать получить значение по ключу  
Б) Если нет кеша — вычислить данные и записать с TTL  
В) Обрабатывать ошибки подключения и падать при критических сбоях  
Г) Всегда возвращать данные из кеша

**Правильные ответы:** А, Б

**Проверяемый ОР:** Понимает. - Как кеширование помогает снизить нагрузку на базу данных.

### Вопрос 10
На планировании архитектуры обсуждаете, как хранить пользовательский кеш в Redis-кластере. Как сформировать ключ?

**Правильный ответ:** Например, `f"user:{user_id}:feed"` (принимаются эквиваленты с неймспейсами)

**Проверяемый ОР:** Понимает. - Какие данные лучше кешировать и как структурировать ключи.

### Вопрос 11
Менеджер проводит флеш-распродажу, руками меняя цены в БД. Какие стратегии инвалидации помогут не показывать покупателям старые данные? Отметь все подходящие варианты.

А) TTL по времени  
Б) Инвалидация при событии  
В) Ручное удаление ключей админ-командой  
Г) Инвалидация по расписанию (батч-очистка ключей по префиксу)
**Правильные ответы:** А, Б, В, Г
**Проверяемый ОР:** Понимает. - Как инвалидация кеша помогает поддерживать актуальность данных.

### Вопрос 12
Отчёт о популярных товарах пересчитывается бэкендом раз в час, но маркетинг хочет видеть почти моментальные данные. Какие подходы помогут держать баланс между скоростью и актуальностью? Отметь все подходящие варианты.

А) Задать короткий TTL и инвалидацию по событию, когда источник данных обновляется  
Б) Кешировать без TTL и игнорировать обновления  
В) Периодически пересчитывать и перезаписывать кеш  
Г) Отказаться от кеша и всегда читать из БД
**Правильные ответы:** А, В
**Проверяемый ОР:** Понимает. - Какие стратегии кеширования лучше подходят для разных сценариев.

### Вопрос 13
Когда дежурный SRE проверяет стабильность, ему нужно быстро узнать, сколько ещё живёт ключ `session:<id>`. Какой командой воспользоваться?
А) `TTL session:<id>`  
Б) `GETTTL session:<id>`  
В) `EXPIRE session:<id>`  
Г) `TIME session:<id>`
**Правильный ответ:** А
**Проверяемый ОР:** Знает. - Что такое TTL (Time to Live) и как его использовать в кешировании.

### Вопрос 14
Перед релизом команды обсуждают архитектуру кеша для API каталога. Какие компоненты точно понадобятся? Отметь все подходящие варианты.
А) Middleware или dependency, которая проверяет кеш  
Б) Сериализация ответа для записи в Redis  
В) Инвалидация при изменении данных  
Г) Автогенерация UI
**Правильные ответы:** А, Б, В
**Проверяемый ОР:** Понимает. - Как интегрировать Redis с FastAPI для кеширования API-ответов.

### Вопрос 15
Логи стали нечитаемыми: много строк, нет структуры. Как перейти на структурированное логирование? Отметь все подходящие варианты.

А) Использовать `logging` с JSON-форматтером  
Б) Добавить контекст (request_id, user_id)  
В) Логировать в stdout  
Г) Снизить уровень до DEBUG для всего

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Понимает. - Как структурированное логирование упрощает анализ логов.

### Вопрос 16
Какой уровень логирования использовать для информации о запуске плановой задачи?

А) INFO  
Б) DEBUG  
В) ERROR  
Г) CRITICAL

**Правильный ответ:** А

**Проверяемый ОР:** Знает. - Уровни логирования: DEBUG, INFO, WARNING, ERROR, CRITICAL.

### Вопрос 17
Ты настраиваешь формат логов. Какие поля стоит включить? Отметь все подходящие варианты.

А) Время события  
Б) Уровень  
В) Имя логгера  
Г) Уникальный идентификатор запроса (`request_id`)

**Правильные ответы:** А, Б, В, Г

**Проверяемый ОР:** Знает. - Как настраивать форматы логов для удобства чтения.

### Вопрос 18
Приложение пишет логи напрямую из эндпоинтов, и записи без request_id. Как исправить? Отметь все подходящие варианты.

А) Передавать `request_id` в контексте логгера через middleware  
Б) Использовать `logger = logging.getLogger(__name__)` и добавлять `extra`  
В) Хранить `request_id` в глобальной переменной
Г) Использовать `logger = logging.getLogger(__name__)` и не добавлять `extra` 

**Правильные ответы:** А, Б

**Проверяемый ОР:** Понимает. - Как структурированное логирование упрощает анализ логов.

### Вопрос 19
Нужно запустить отчёт об оплатах каждые 15 минут. Какие шаги нужны при использовании APScheduler? Отметь все подходящие варианты.

А) Создать `AsyncIOScheduler`  
Б) Добавить задачу с `trigger='interval', minutes=15`  
В) Запустить `scheduler.start()`  
Г) Запустить `scheduler.stop()`

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Понимает. - Как APScheduler помогает в планировании периодических задач.

### Вопрос 20
В продакшне задача APScheduler внезапно прекращает работать после исключения. Как защититься?

А) Оборачивать задачу в try/except  
Б) Добавить уведомления при исключениях  
В) Ничего не нужно делать, задача перезапустится автоматически  
Г) Логировать ошибки

**Правильные ответы:** А, Б, Г

**Проверяемый ОР:** Понимает. - Какие ошибки могут возникать при работе с фоновыми задачами и как их устранять.

### Вопрос 21
BackgroundTasks FastAPI запускает пост-обработку письма. Чем он отличается от APScheduler? Отметь все подходящие варианты.

А) BackgroundTasks выполняет задачи после ответа на конкретный запрос  
Б) APScheduler запускает задачи по расписанию без привязки к запросу  
В) BackgroundTasks не подходит для периодических задач  
Г) APScheduler работает только синхронно

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Знает. - Различие между BackgroundTasks в FastAPI и APScheduler.

### Вопрос 22
Нужно отправлять отчёт в 08:00 по будням. Какой триггер APScheduler выбрать?

**Правильный ответ:** `CronTrigger(day_of_week="mon-fri", hour=8, minute=0)` (принимаются эквиваленты)

**Проверяемый ОР:** Понимает. - Почему фоновые задачи важны для выполнения длительных операций.

### Вопрос 23
Эндпоинт требует подключения к БД и кешу. Как организовать зависимости, чтобы переиспользовать соединения?

А) Создать зависимость `get_db` и использовать Depends, возвращая сессию  
Б) Создать зависимость `get_cache` для Redis  
В) Создавать соединение внутри эндпоинта через глобальную переменную  
Г) Передавать подключения через аргументы эндпоинта

**Правильные ответы:** А, Б

**Проверяемый ОР:** Понимает. - Как DI помогает в интеграции с внешними сервисами и базами данных.

### Вопрос 24
Зачем использовать DI при поддержке больших приложений? Отметь все подходящие варианты.

А) Зависимости можно централизованно обновлять и рефакторить без правок во всех эндпоинтах  
Б) Можно подключать разные реализации сервисов в зависимости от окружения  
В) Проще контролировать жизненный цикл ресурсов (открытие/закрытие соединений)  
Г) Не нужно обновлять документацию Swagger

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Понимает. - Преимущества DI для тестирования и поддержки кода.

### Вопрос 25
Нужно объявить асинхронную зависимость, которая подключается к Redis и закрывает соединение после использования. Какой шаблон подойдёт?

**Правильный ответ:**
```python
async def get_redis():
    async with aioredis.from_url(URL) as conn:
        yield conn
```
(принимаются эквиваленты с `yield`)

**Проверяемый ОР:** Понимает. - Как асинхронные зависимости улучшают производительность приложения.

### Вопрос 26
Ты хочешь ограничить доступ к эндпоинту по API-ключу. Как использовать Depends для проверки заголовка?

А) Создать зависимость `verify_api_key` и бросать `HTTPException` при несоответствии  
Б) Проверять ключ внутри каждого эндпоинта  
В) Хранить ключ в глобальной переменной без проверки  
Г) Передавать ключ через swagger

**Правильный ответ:** А

**Проверяемый ОР:** Понимает. - Как Depends помогает централизовать проверки доступа.

### Вопрос 27
Ты хочешь, чтобы middleware ставил `request_id`, а зависимость логировала его. Что гарантирует последовательность?

А) Middleware выполняется до зависимостей, поэтому зависимость увидит `request.state`  
Б) Зависимости выполняются до middleware  
В) Порядок не определён  
Г) Нужно вручную вызывать middleware из зависимости

**Правильный ответ:** А

**Проверяемый ОР:** Понимает. - Как middleware интегрируется в жизненный цикл запроса в FastAPI.

### Вопрос 28
Тебе нужно инжектировать конфигурацию приложения в несколько эндпоинтов. Какой подход масштабируется?

А) Создать зависимость `get_settings`, возвращающую объект настроек  
Б) Использовать глобальную переменную в модуле  
В) Передавать настройки через аргументы вручную  
Г) Читать файл конфигурации в каждом эндпоинте

**Правильный ответ:** А

**Проверяемый ОР:** Понимает. - Почему DI упрощает управление зависимостями в крупных проектах.

### Вопрос 29
Ты хочешь логировать `request_id` в каждом логе без явного указания. Как комбинировать middleware и logging?

А) Middleware добавляет `request_id` в `contextvars`, логгер использует `LoggerAdapter` или фильтр  
Б) Логгер читает `request.headers` напрямую  
В) Использовать print  
Г) Не логировать `request_id`

**Правильный ответ:** А

**Проверяемый ОР:** Понимает. - Как структурированное логирование упрощает анализ логов.

### Вопрос 30
Запрос к `/reports` должен сначала проверить кеш, иначе дернуть БД и записать результат. В какой последовательности расположишь слои?

А) Middleware → Dependency (кеш) → Сервис (БД)  
Б) Сервис → Middleware → Dependency  
В) Dependency → Middleware → Сервис  
Г) Случайный порядок

**Правильный ответ:** А

**Проверяемый ОР:** Понимает. - Как кеширование улучшает производительность приложения.

### Вопрос 31
Нужно удалить кеш при обновлении товара. Какую команду Redis вызовешь?

**Правильный ответ:** `DEL key` (принимаются `await redis.delete(key)`)

**Проверяемый ОР:** Понимает. - Как инвалидация кеша помогает поддерживать актуальность данных.

### Вопрос 32
Часть запросов приходит без заголовка `Authorization`, хотя все защищённые эндпоинты его требуют. Как организовать проверку через middleware, чтобы улучшить безопасность? Отметь все подходящие варианты.

А) Проверять наличие и валидность токена в middleware, при отсутствии отвечать 401 без вызова `call_next`  
Б) Логировать все случаи отсутствия токена и отправлять метрики безопасности  
В) Пропускать запросы без токена, если это запрос к `/health`  
Г) Полностью блокировать все запросы без заголовка независимо от маршрута

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Понимает. - Как middleware может улучшить безопасность приложения.

### Вопрос 33
Бэкенд обрабатывает тяжёлые отчёты в фоновом планировщике на том же сервере, что и REST API. После запуска фоновых задач latency API вырос. Что поможет снизить влияние на производительность? Отметь все подходящие варианты.

А) Вынести фоновый воркер в отдельный процесс или сервис  
Б) Ограничить количество одновременных задач через пул исполнителей  
В) Кешировать промежуточные результаты и отдавать их, а не пересчитывать каждый раз  
Г) Поднять уровень логирования до DEBUG для задач

**Правильные ответы:** А, Б, В

**Проверяемый ОР:** Понимает. - Как фоновые задачи влияют на производительность приложения.

### Вопрос 34
Сформулируй три ключевых поля для структурированного логирования запроса. Напиши через запятую.

**Правильный ответ:** `timestamp, level, message` (принимаются дополнения типа `request_id`, `path`)

**Проверяемый ОР:** Знает. - Что такое логирование и зачем оно нужно.

